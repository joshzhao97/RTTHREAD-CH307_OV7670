/*
 * Copyright (c) 2006-2021, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes
 * 2022-08-23     zm       the first version
 */
#include "oled.h"
#include "ASCII_8x16.h"
#define DBG_TAG "OLED.0.96"
#define DBG_LVL DBG_INFO
uint8_t OLED_GRAM[128][8];
/*写入命令*/
void OLED_Wite_CMD(u8 cmd)
{
    I2C_Start();
    I2C_Write_Byte(OLED_ADDRESS);
    I2C_Write_Ack();
    I2C_Write_Byte(0x00);
    I2C_Write_Ack();
    I2C_Write_Byte(cmd);
    I2C_Write_Ack();
    I2C_Stop();
}
/*写入数据*/
void OLED_Wite_Data(u8 data)
{
    I2C_Start();
    I2C_Write_Byte(OLED_ADDRESS);
    I2C_Write_Ack();
    I2C_Write_Byte(0x40);
    I2C_Write_Ack();
    I2C_Write_Byte(data);
    I2C_Write_Ack();
    I2C_Stop();
}
void OLED_Write_On(void)
{
    OLED_Wite_CMD(0x8d);
    OLED_Wite_CMD(0x14);
    OLED_Wite_CMD(0xaf);
}
void OLED_Write_Off(void)
{
    OLED_Wite_CMD(0x8d);
    OLED_Wite_CMD(0x10);
    OLED_Wite_CMD(0xae);
}
void OLED_Write_Clear(void)
{
    for(u8 i = 0;i < 8;i++)//8页
    {
            OLED_Wite_CMD(0xb0 + i);
            OLED_Wite_CMD(0x00);
            OLED_Wite_CMD(0x10);

        for(u8 n = 0; n < 128;n++)//128列
        {
        OLED_Wite_Data(0x00);
        }
    }
}
void OLED_Write_Init(void)
{
    rt_thread_mdelay(200);
    OLED_Wite_CMD(0xa8);
    OLED_Wite_CMD(0x3f);
    OLED_Wite_CMD(0xda);
    OLED_Wite_CMD(0x12);

    OLED_Wite_CMD(0xd3);
    OLED_Wite_CMD(0x00);
    OLED_Wite_CMD(0x40);
    OLED_Wite_CMD(0xa1);
    OLED_Wite_CMD(0x81);
    OLED_Wite_CMD(0xff);
    OLED_Wite_CMD(0xa4);
    OLED_Wite_CMD(0xa6);
    OLED_Wite_CMD(0xd5);
    OLED_Wite_CMD(0xf0);
    OLED_Wite_CMD(0x8d);
    OLED_Wite_CMD(0x14);
    OLED_Wite_CMD(0xae);
    OLED_Wite_CMD(0x20);
    OLED_Wite_CMD(0x02);
    OLED_Wite_CMD(0xb0);
    OLED_Wite_CMD(0xc8);
    OLED_Wite_CMD(0x00);
    OLED_Wite_CMD(0x10);
    OLED_Wite_CMD(0x40);
    OLED_Wite_CMD(0xd9);
    OLED_Wite_CMD(0x22);
    OLED_Wite_CMD(0xdb);
    OLED_Wite_CMD(0x20);
    OLED_Wite_CMD(0xaf);

    OLED_Write_Off();
    OLED_Write_Clear();
}
void OLED_Write_Display(u8 x,u8 y,u8 hight,u8 weight,u8 *data)
{
    for(u8 i = 0;i < hight;i++)
    {
        OLED_Wite_CMD((0xb0 | i) + x);
        OLED_Wite_CMD(0x10 + (y >> 4 & 0x0f));
        OLED_Wite_CMD(y & 0x0f);

        for(u8 j = 0;j < weight;j++)
        {
            OLED_Wite_Data(*data++);
        }
    }
}
/*定位函数*/
void OLED_SetPos(u8 x,u8 y)
{
    OLED_Wite_CMD(0xb0 + y/8);
    OLED_Wite_CMD(x & 0x0f);
    OLED_Wite_CMD(((x & 0xf0) >> 4) | 0x10);
}
/**
 * @brief 在指定位置画点函数
 * @param x:列地址(0~127)，y:行地址(0~63)
 * @param mode:1 填充，0 清空
 * @retval None
 */
void OLED_DrawPoint(u8 x,u8 y,u8 mode)
{
 u8 page,bx,temp=0;
 OLED_SetPos(x,y);
 if(x>127||y>63) return; //超出范围
 page=y/8;
 bx=y%8;
 temp=1<<bx;
 if(mode) OLED_GRAM[x][page]|=temp;
 else OLED_GRAM[x][page]&=~temp;
 /* 写入显示缓存 */
 OLED_Wite_Data(OLED_GRAM[x][page]);
}


//显示英文与数字8*16的ASCII码
//取模大小为8*16，取模方式为“从左到右从上到下”“纵向8点下高位”
void OLED_DISPLAY_8x16(u8 x, //显示汉字的页坐标（从0到7）（此处不可修改）
                        u8 y, //显示汉字的列坐标（从0到128）
                        u16 w){ //要显示汉字的编号
    u8 j,t,c=0;
    y=y+2; //因OLED屏的内置驱动芯片是从0x02列作为屏上最左一列，所以要加上偏移量
    for(t=0;t<2;t++){
        OLED_Wite_CMD(0xb0+x); //页地址（从0xB0到0xB7）
        OLED_Wite_CMD(y/16+0x10); //起始列地址的高4位
        OLED_Wite_CMD(y%16);    //起始列地址的低4位
        for(j=0;j<8;j++){ //整页内容填充
            I2C_Write_Byte(ASCII_8x16[(w*16)+c-512]);//为了和ASII表对应要减512
            c++;}x++; //页地址加1
    }
}

//向LCM发送一个字符串,长度64字符之内。
//应用：OLED_DISPLAY_8_16_BUFFER(0," DoYoung Studio",12);
//i 字符长度 row:行号
void OLED_DISPLAY_8x16_BUFFER(u8 row,u8 *str,u8 i){
    u8 r=0;
    while((i) != r){
        OLED_DISPLAY_8x16(row,r*8,*str++);
        r++;
    }
}
/*OLED专用printf函数
row:行号
fmt：传参字符
*/
void OLED_printf(u8 row,char *fmt, ...)
{
    char buff[17];
    uint16_t i = 0;
    va_list arg_ptr;
    va_start(arg_ptr,fmt);
    vsnprintf(buff,17,fmt,arg_ptr);
    i = rt_strlen(buff);
    if(rt_strlen(buff) > 16) i = 16;
    OLED_DISPLAY_8x16_BUFFER(row,(u8 *)buff,i);
    va_end(arg_ptr);
}

void OLED_Write_Num(u8 x,u8 y,u8 num)//显示两位数据
{
    u8 number[10][64] = {
            /*--  文字:  0  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xC0,0x40,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,
        0x00,0xF8,0xFE,0xFF,0xFF,0x03,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFE,0xF8,0x00,
        0x00,0x3F,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0xFF,0x1F,0x00,
        0x00,0x00,0x00,0x01,0x03,0x07,0x06,0x06,0x06,0x06,0x07,0x03,0x01,0x00,0x00,0x00,

        /*--  文字:  1  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x01,0x01,0x01,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x04,0x04,0x04,0x07,0x07,0x07,0x07,0x06,0x04,0x04,0x00,0x00,0x00,

        /*--  文字:  2  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0x80,0xC0,0xC0,0xC0,0x40,0x40,0xC0,0xC0,0xC0,0x80,0x00,0x00,0x00,
        0x00,0x0E,0x1F,0x1F,0x1F,0x00,0x00,0x00,0x00,0x00,0xC1,0xFF,0xFF,0x7F,0x0C,0x00,
        0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0xC0,0xC0,0xC0,0x00,
        0x00,0x07,0x07,0x07,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x07,0x07,0x07,0x00,0x00,

        /*--  文字:  3  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0x80,0xC0,0xC0,0x40,0x40,0xC0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,
        0x00,0x00,0x0F,0x0F,0x0F,0x80,0x80,0xC0,0xC0,0xC0,0xFF,0x7F,0x3F,0x1E,0x00,0x00,
        0x00,0xC0,0xE0,0xE0,0xE0,0x00,0x00,0x00,0x01,0x01,0x03,0xFF,0xFF,0xFC,0x70,0x00,
        0x00,0x00,0x03,0x03,0x07,0x06,0x04,0x04,0x06,0x06,0x07,0x03,0x03,0x01,0x00,0x00,

        /*--  文字:  4  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x80,0xC0,0xF0,0x78,0x1E,0x0F,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
        0x10,0x1C,0x1E,0x17,0x13,0x10,0x10,0x10,0x10,0xFF,0xFF,0xFF,0x10,0x10,0x10,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x06,0x07,0x07,0x07,0x06,0x04,0x04,0x00,

        /*--  文字:  5  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,
        0x00,0x00,0xFE,0xFF,0xFF,0xC0,0xC0,0x60,0x60,0xE0,0xC0,0xC0,0x80,0x00,0x00,0x00,
        0x00,0xE0,0xE1,0xF3,0xE3,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0x3C,0x00,
        0x00,0x00,0x01,0x03,0x07,0x06,0x06,0x04,0x04,0x06,0x07,0x07,0x03,0x01,0x00,0x00,

        /*--  文字:  6  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xC0,0x40,0x40,0xC0,0xC0,0xC0,0x80,0x00,0x00,
        0x00,0xF0,0xFC,0xFF,0xFF,0xC3,0xC1,0xC0,0x60,0xE0,0xC3,0xC3,0xC3,0x83,0x00,0x00,
        0x00,0x7F,0xFF,0xFF,0xFF,0x81,0x00,0x00,0x00,0x00,0x00,0xC7,0xFF,0xFF,0x7E,0x00,
        0x00,0x00,0x01,0x03,0x07,0x07,0x06,0x06,0x04,0x06,0x06,0x07,0x03,0x01,0x00,0x00,

        /*--  文字:  7  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,
        0x00,0x06,0x07,0x07,0x01,0x00,0x00,0x00,0xC0,0xF0,0x7C,0x1F,0x07,0x01,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0xE0,0xFC,0xFF,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x07,0x07,0x07,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

        /*--  文字:  8  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0x80,0xC0,0xC0,0xC0,0x40,0x40,0xC0,0xC0,0xC0,0x80,0x00,0x00,0x00,
        0x00,0x1E,0x3F,0x7F,0xF3,0xE0,0xC0,0xC0,0x80,0x80,0xC0,0xFF,0x7F,0x3F,0x0C,0x00,
        0x00,0xF8,0xFE,0xFF,0x07,0x03,0x01,0x01,0x03,0x07,0x07,0xDF,0xFE,0xFC,0x70,0x00,
        0x00,0x00,0x03,0x03,0x07,0x06,0x06,0x04,0x04,0x06,0x06,0x07,0x03,0x01,0x00,0x00,

        /*--  文字:  9  --*/
        /*--  宋体23;  此字体下对应的点阵为：宽x高=16x31   --*/
        /*--  高度不是8的倍数，现调整为：宽度x高度=16x32  --*/
        0x00,0x00,0x00,0x80,0xC0,0xC0,0xC0,0x40,0x40,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,
        0x00,0xFE,0xFF,0xFF,0x83,0x00,0x00,0x00,0x00,0x00,0x81,0xFF,0xFF,0xFE,0xF8,0x00,
        0x00,0x01,0x83,0x87,0x87,0x86,0x0E,0x0C,0x06,0x06,0xE7,0xFF,0xFF,0x7F,0x0F,0x00,
        0x00,0x00,0x03,0x07,0x07,0x07,0x04,0x06,0x06,0x07,0x03,0x03,0x00,0x00,0x00,0x00,
    };
    OLED_Write_Display(x,y,4,16,number[num/10]);
    OLED_Write_Display(x,y+16*2,4,16,number[num%10]);
}

rt_err_t OLED_Init(rt_device_t dev)
{
    OLED_Write_Init();
OLED_Write_On();
    rt_kprintf("oled init sucess\r\n");
    return RT_EOK;
}
rt_err_t OLED_Open(rt_device_t dev,rt_uint16_t oflag)
{
        //dev->ref_count =1;//很重要，不然会在read设备时直接返回错误码
    OLED_Write_Clear();
    rt_kprintf("open oled sucess\r\n");
    return RT_EOK;
}

rt_size_t OLED_Write (rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size)//pos页 size行
{
    RT_ASSERT(buffer);//
    u8* pi = (u8*)buffer;
    u8 num = *pi;
    if(dev->type == RT_Device_Class_I2CBUS)
    {
        if(pos > 10)//写入数字
        {
            OLED_Write_Num((u8)(pos - 10),(u8)size,num);
        }
        else//写入字符
            OLED_Write_Display((u8)pos,(u8)size,4,32,(u8*)buffer);
        return RT_EOK;
    }
    return RT_ERROR;

}
rt_err_t OLED_close(rt_device_t dev)
{
rt_kprintf("oled device close\r\n");
    rt_device_destroy(dev);
    return RT_EOK;
}
int rt_OLED_Init(void)
{
rt_device_t OLED_dev;
    OLED_dev = rt_device_create(RT_Device_Class_I2CBUS,32);
    if(OLED_dev == RT_NULL)
    {
    LOG_E("device OLED create failed\r\n");
        return -RT_ENOMEM;
    }
    OLED_dev->init = OLED_Init;
    OLED_dev->open = OLED_Open;
    OLED_dev->write = OLED_Write;
    OLED_dev->close = OLED_close;
    rt_device_register(OLED_dev,"OLED.0.96",RT_DEVICE_FLAG_WRONLY);
    return 1;
}
//INIT_BOARD_EXPORT(rt_OLED_Init);

